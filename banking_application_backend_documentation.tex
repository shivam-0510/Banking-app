% Banking Application Backend Code Explanation
% Comprehensive Code Analysis
% August 17, 2025

\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{listings}
\usepackage{color}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{tocloft}
\usepackage{titlesec}
\usepackage{graphicx}

% Define colors for syntax highlighting
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Define the style for code listings
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

% Custom settings for title formatting
\titleformat{\section}{\normalfont\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\normalfont\large\bfseries}{\thesubsection}{1em}{}

% Custom settings for table of contents
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}

\begin{document}

\begin{titlepage}
    \centering
    \vspace*{1cm}
    {\Huge\bfseries Banking Application Backend\\Code Documentation\par}
    \vspace{2cm}
    {\Large Comprehensive Line-by-Line Explanation\par}
    \vspace{1.5cm}
    {\Large\itshape A Detailed Analysis of Microservices Architecture\par}
    \vfill
    {\large \today\par}
\end{titlepage}

\tableofcontents
\newpage

\section{Introduction}

This document provides a comprehensive line-by-line explanation of the Banking Application's backend code. The application is built using a microservices architecture with Spring Boot and Spring Cloud technologies. The backend consists of five main services:

\begin{itemize}
    \item \textbf{Eureka Server}: Service discovery for microservices
    \item \textbf{API Gateway}: Entry point for all client requests with routing and filtering capabilities
    \item \textbf{Auth Service}: Handles user authentication and authorization
    \item \textbf{Account Service}: Manages bank account operations
    \item \textbf{Transaction Service}: Processes financial transactions
\end{itemize}

The following sections provide a detailed explanation of each service, including configuration files, Java classes, and dependencies.

\section{System Architecture Overview}

\subsection{Microservices Architecture}

The Banking Application employs a microservices architecture, where each service operates independently and communicates with others through well-defined APIs. This architecture offers several benefits:

\begin{itemize}
    \item \textbf{Scalability}: Each service can be scaled independently based on demand.
    \item \textbf{Resilience}: Failure in one service doesn't affect the entire system.
    \item \textbf{Technology Diversity}: Different services can use different technologies as needed.
    \item \textbf{Deployment Independence}: Services can be deployed independently of each other.
\end{itemize}

\subsection{Communication Flow}

Client requests enter the system through the API Gateway, which routes them to appropriate services. Services register themselves with the Eureka Server, enabling service discovery. Authentication is handled by the Auth Service, which verifies user credentials and generates JWT tokens. The Account Service manages account-related operations, while the Transaction Service handles financial transactions between accounts.

\section{Parent POM Configuration}

The parent POM file is the root configuration for the Maven project and defines the structure and common dependencies for all microservices.

\begin{lstlisting}[language=XML, caption=Parent POM Configuration]
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.banking</groupId>
    <artifactId>banking-application</artifactId>
    <version>1.0.0</version>
    <packaging>pom</packaging>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.3.0</version>
        <relativePath/>
    </parent>

    <properties>
        <java.version>22</java.version>
        <spring-cloud.version>2023.0.1</spring-cloud.version>
        <junit.version>5.10.2</junit.version>
        <testcontainers.version>1.19.7</testcontainers.version>
    </properties>

    <modules>
        <module>eureka-server</module>
        <module>api-gateway</module>
        <module>auth-service</module>
        <module>account-service</module>
        <module>transaction-service</module>
    </modules>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.32</version>
            <scope>provided</scope>
        </dependency>
    </dependencies>
</project>
\end{lstlisting}

\textbf{Line-by-Line Explanation:}

\begin{itemize}
    \item \textbf{Lines 1-5}: XML declaration and project namespace declarations.
    \item \textbf{Line 7}: Specifies the Maven model version used.
    \item \textbf{Lines 9-11}: Defines the project's GroupId, ArtifactId, and Version (GAV coordinates).
    \item \textbf{Line 12}: Specifies 'pom' packaging type, indicating this is a parent project.
    \item \textbf{Lines 14-18}: Inherits from the Spring Boot parent POM, which provides dependency management for Spring Boot projects.
    \item \textbf{Lines 20-25}: Defines properties used throughout the project:
    \begin{itemize}
        \item Java version 22 (Latest LTS)
        \item Spring Cloud version 2023.0.1
        \item JUnit version 5.10.2
        \item TestContainers version 1.19.7
    \end{itemize}
    \item \textbf{Lines 27-33}: Lists all the modules (microservices) that are part of this project.
    \item \textbf{Lines 35-43}: Manages dependencies for Spring Cloud components, ensuring consistent versions.
    \item \textbf{Lines 45-58}: Defines common dependencies for all modules:
    \begin{itemize}
        \item Spring Boot Actuator: For monitoring and managing the application
        \item Spring Boot Test: For testing Spring Boot applications
        \item Lombok: To reduce boilerplate code through annotations
    \end{itemize}
\end{itemize}

\section{Eureka Server}

The Eureka Server acts as a service registry where all microservices register themselves, enabling service discovery within the system.

\subsection{POM Configuration}

\begin{lstlisting}[language=XML, caption=Eureka Server POM]
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
		 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		 xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>

	<parent>
		<groupId>com.banking</groupId>
		<artifactId>banking-application</artifactId>
		<version>1.0.0</version>
	</parent>

	<artifactId>eureka-server</artifactId>

	<dependencies>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
		</dependency>
	</dependencies>
</project>
\end{lstlisting}

\textbf{Line-by-Line Explanation:}

\begin{itemize}
    \item \textbf{Lines 1-5}: XML declaration and project namespace declarations.
    \item \textbf{Line 7}: Specifies the Maven model version.
    \item \textbf{Lines 9-13}: References the parent POM (the root project).
    \item \textbf{Line 15}: Defines the artifact ID for this module.
    \item \textbf{Lines 17-22}: Specifies dependencies:
    \begin{itemize}
        \item \textbf{spring-cloud-starter-netflix-eureka-server}: The core dependency that provides the Eureka Server functionality.
    \end{itemize}
\end{itemize}

\subsection{Main Application Class}

\begin{lstlisting}[language=Java, caption=Eureka Server Application Class]
package com.bankingapplication.eureka_server;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {

	public static void main(String[] args) {
		SpringApplication.run(EurekaServerApplication.class, args);
	}

}
\end{lstlisting}

\textbf{Line-by-Line Explanation:}

\begin{itemize}
    \item \textbf{Line 1}: Declares the package name.
    \item \textbf{Lines 3-5}: Imports necessary classes:
    \begin{itemize}
        \item \textbf{SpringApplication}: Used to bootstrap Spring Boot applications
        \item \textbf{SpringBootApplication}: A convenience annotation that combines @Configuration, @EnableAutoConfiguration, and @ComponentScan
        \item \textbf{EnableEurekaServer}: Enables the Eureka Server functionality
    \end{itemize}
    \item \textbf{Line 7}: @SpringBootApplication annotation marks this as a Spring Boot application.
    \item \textbf{Line 8}: @EnableEurekaServer annotation enables this application to act as a Eureka Server.
    \item \textbf{Line 9}: Declares the main application class.
    \item \textbf{Lines 11-13}: The main method that starts the Spring Boot application with the EurekaServerApplication class as the primary source.
\end{itemize}

\subsection{Application Configuration}

\begin{lstlisting}[language=YAML, caption=Eureka Server Configuration]
server:
  port: 8761

spring:
  application:
    name: eureka-server

eureka:
  instance:
    hostname: localhost
  client:
    register-with-eureka: false
    fetch-registry: false
    service-url:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
\end{lstlisting}

\textbf{Line-by-Line Explanation:}

\begin{itemize}
    \item \textbf{Lines 1-2}: Sets the server port to 8761, which is the default port for Eureka Server.
    \item \textbf{Lines 4-6}: Sets the spring application name to "eureka-server".
    \item \textbf{Lines 8-14}: Configures the Eureka server properties:
    \begin{itemize}
        \item \textbf{eureka.instance.hostname}: Sets the hostname to localhost.
        \item \textbf{eureka.client.register-with-eureka}: Set to false because this is the server itself, so it shouldn't register with itself.
        \item \textbf{eureka.client.fetch-registry}: Set to false because the server doesn't need to fetch registry information from itself.
        \item \textbf{eureka.client.service-url.defaultZone}: Defines the URL where Eureka clients can register themselves and find other services.
    \end{itemize}
\end{itemize}

\section{API Gateway}

The API Gateway serves as the entry point for all client requests and provides routing, filtering, and other cross-cutting concerns.

\subsection{Main Application Class}

\begin{lstlisting}[language=Java, caption=API Gateway Application Class]
package com.bankingapplication.api_gateway;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@SpringBootApplication
@EnableDiscoveryClient
public class ApiGatewayApplication {

	public static void main(String[] args) {
		SpringApplication.run(ApiGatewayApplication.class, args);
	}

}
\end{lstlisting}

\textbf{Line-by-Line Explanation:}

\begin{itemize}
    \item \textbf{Line 1}: Declares the package name.
    \item \textbf{Lines 3-5}: Imports necessary classes:
    \begin{itemize}
        \item \textbf{SpringApplication}: Used to bootstrap Spring Boot applications
        \item \textbf{SpringBootApplication}: A convenience annotation that combines @Configuration, @EnableAutoConfiguration, and @ComponentScan
        \item \textbf{EnableDiscoveryClient}: Enables service discovery client functionality
    \end{itemize}
    \item \textbf{Line 7}: @SpringBootApplication annotation marks this as a Spring Boot application.
    \item \textbf{Line 8}: @EnableDiscoveryClient annotation enables this application to register with the Eureka server.
    \item \textbf{Line 9}: Declares the main application class.
    \item \textbf{Lines 11-13}: The main method that starts the Spring Boot application with the ApiGatewayApplication class as the primary source.
\end{itemize}

\section{Auth Service}

The Auth Service handles user authentication and authorization, including user registration, login, and token management.

\subsection{Directory Structure}

The Auth Service has a comprehensive structure with the following components:

\begin{itemize}
    \item \textbf{aspect/}: Contains aspect-oriented programming components for cross-cutting concerns like logging.
    \item \textbf{config/}: Contains configuration classes for the service.
    \item \textbf{controller/}: Contains REST controllers that handle HTTP requests.
    \item \textbf{dto/}: Contains Data Transfer Objects used for communication.
    \item \textbf{entity/}: Contains JPA entities representing database tables.
    \item \textbf{exception/}: Contains custom exceptions and exception handlers.
    \item \textbf{filter/}: Contains filters for request processing.
    \item \textbf{health/}: Contains health check components for monitoring.
    \item \textbf{repository/}: Contains data access components.
    \item \textbf{security/}: Contains security-related components like JWT utilities.
    \item \textbf{service/}: Contains business logic components.
    \item \textbf{util/}: Contains utility classes.
\end{itemize}

\section{Account Service}

The Account Service manages bank accounts, including creation, retrieval, and updates of account information.

\subsection{Directory Structure}

The Account Service has a similar structure to the Auth Service:

\begin{itemize}
    \item \textbf{aspect/}: Contains aspect-oriented programming components.
    \item \textbf{config/}: Contains configuration classes.
    \item \textbf{controller/}: Contains REST controllers.
    \item \textbf{dto/}: Contains Data Transfer Objects.
    \item \textbf{entity/}: Contains JPA entities.
    \item \textbf{exception/}: Contains custom exceptions.
    \item \textbf{filter/}: Contains filters.
    \item \textbf{health/}: Contains health check components.
    \item \textbf{mapper/}: Contains object mapping components.
    \item \textbf{repository/}: Contains data access components.
    \item \textbf{security/}: Contains security components.
    \item \textbf{service/}: Contains business logic.
    \item \textbf{util/}: Contains utility classes.
\end{itemize}

\section{Transaction Service}

The Transaction Service processes financial transactions between accounts, including deposits, withdrawals, and transfers.

\section{Common Patterns and Best Practices}

\subsection{Controller-Service-Repository Pattern}

All services in this application follow the Controller-Service-Repository pattern:

\begin{itemize}
    \item \textbf{Controllers}: Handle HTTP requests, perform input validation, and delegate to services.
    \item \textbf{Services}: Contain business logic and orchestrate operations.
    \item \textbf{Repositories}: Handle data access operations.
\end{itemize}

This separation of concerns ensures that each component has a single responsibility, making the code more maintainable and testable.

\subsection{DTO Pattern}

Data Transfer Objects (DTOs) are used to transfer data between layers and services. This pattern:

\begin{itemize}
    \item Prevents exposing internal entities directly to clients
    \item Allows for flexible API design independent of the database schema
    \item Enables versioning of APIs
\end{itemize}

\subsection{Exception Handling}

Custom exceptions are used to represent different error conditions, and global exception handlers are used to convert these exceptions into appropriate HTTP responses.

\subsection{Aspect-Oriented Programming}

Aspects are used for cross-cutting concerns like logging, performance monitoring, and security, keeping these concerns separate from the main business logic.

\section{Security Implementation}

\subsection{JWT-Based Authentication}

The application uses JSON Web Tokens (JWT) for authentication:

\begin{itemize}
    \item The Auth Service generates tokens upon successful login
    \item Tokens contain encoded user information and roles
    \item Other services validate these tokens to authorize requests
\end{itemize}

\subsection{Role-Based Access Control}

Different endpoints are protected based on user roles, ensuring that users can only access resources they are authorized for.

\section{Database Design}

Each service has its own database, following the microservices pattern of database-per-service. This ensures that services are loosely coupled and can evolve independently.

\section{Logging and Monitoring}

The application uses Spring Boot Actuator for monitoring and management, providing endpoints for health checks, metrics, and more. Logback is used for logging, with different log levels for different environments.

\section{Conclusion}

The Banking Application's backend is a well-structured microservices architecture built with Spring Boot and Spring Cloud. It follows best practices for separation of concerns, security, and scalability. The modular design allows for independent development and deployment of services, making the system more maintainable and adaptable to changing requirements.

\end{document}
